Java类加载方式：
    显示加载：class.forname();
    隐式加载：new

java类装载器：
    Bootstrp loader:
        实现：C++实现
        加载目录:
            %JAVA_HOME%/jre/lib
            %JAVA_HOME%/jre/classes
            -Xbootclasspath参数指定的路径
    ExtClassLoader：
        实现类：sun.misc.Launcher$ExtClassLoader
        加载目录:
            %JAVA_HOME%/jre/lib/ext
            系统变量:java.ext.dirs
    AppClassLoader:
        实现类:sun.misc.Launcher$AppClassLoader
        加载目录:
            系统变量:classpath
    自定义类加载器:
        描述:extends java.lang.ClassLoader
            一般重写findClass方法

加载模型:全盘责任委托机制
    全盘责任:
        当一个ClassLoder装载一个类时，
        除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入
    委托机制:
        先委托父类装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类
    模型理由:
        为安全考虑:系统类不会被恶意更改,如java.lang.String;在jvm底层：java.*必须由bootstrp加载
        节约资源:不重复加载类
加载具体实现:
    伴随生成相应的Class对象:由classLoader.defineClass()定义(这句话存在疑问,是Class对象就是加载的对象本身么?)
    1.装载
        查找和导入Class文件
    2.链接
        a)检查  文件正确性
        b)准备  静态变量分配存储空间
        c)解析(opt)  符号引用转为直接引用
    3.初始化

线程上下文加载器:
    java.lang.Thread的ContextClassLoader,
    ContextClassLoader是当前线程当前类的类加载器:是加载当前类的类加载器;而ClassLoader是当前类加载其它类的加载器
    子线程继承父线程的上下文类加载器,Java应用的初始上下文加载器是AppClassLoader

Web容器中的类加载:
    加载顺序:首先尝试去加载某个类，如果找不到再代理给父类加载器

OSGi与类加载器:
    每个bundle都有自己的ClassLoader